# 技術選定理由 (Technology Adoption Rationale)

このドキュメントは、財務計画計算機アプリケーションで採用した各技術の選定理由と、検討した代替案を説明します。

## 目次

- [アーキテクチャパターン](#アーキテクチャパターン)
- [フロントエンド](#フロントエンド)
- [バックエンド](#バックエンド)
- [データベース](#データベース)
- [認証・認可](#認証認可)
- [インフラストラクチャ](#インフラストラクチャ)
- [開発ツール](#開発ツール)

---

## アーキテクチャパターン

### Clean Architecture / DDD

**採用理由:**

1. **ビジネスロジックの保護**
   - ドメインロジックをフレームワークから独立させる
   - 将来的なフレームワーク変更への耐性

2. **テスタビリティ**
   - 各層を独立してテスト可能
   - モックやスタブの注入が容易

3. **保守性の向上**
   - 関心の分離による変更影響範囲の限定
   - 新規メンバーの学習コストの削減

4. **金融アプリケーションに適合**
   - 複雑なビジネスルールを明確に表現
   - ドメインモデルが金融計算ロジックと一致

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **MVC (Model-View-Controller)** | ビジネスロジックがコントローラーに散在しがち。テストが困難。金融計算のような複雑なロジックには不適切 |
| **トランザクションスクリプト** | 小規模には適しているが、複雑な金融計算には保守性が低下。将来の機能拡張が困難 |
| **マイクロサービス** | 現段階では過剰設計。運用コストが高く、小規模チームには不向き。モノリスで十分 |

---

## フロントエンド

### Next.js 14

**採用理由:**

1. **App Router の活用**
   - React Server Componentsによるパフォーマンス最適化
   - レイアウトの共有が容易
   - ストリーミングSSRでUX向上

2. **SEO対応**
   - サーバーサイドレンダリング（SSR）標準装備
   - メタデータAPI による簡単なSEO設定
   - 将来的なマーケティングページ展開に有利

3. **TypeScript統合**
   - 型安全性による開発体験向上
   - エディタ補完の充実

4. **画像最適化**
   - 自動的な画像最適化
   - レスポンシブ画像対応

5. **エコシステム**
   - 豊富なライブラリとプラグイン
   - 大規模コミュニティ
   - Vercel による継続的な開発

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Create React App (CRA)** | SSR非対応。SEOに弱い。開発体験がNext.jsに劣る。メンテナンスが事実上停止 |
| **Vite + React** | SSRの設定が複雑。Next.jsのような統合されたソリューションがない。初期設定コストが高い |
| **Remix** | 新しすぎてエコシステムが未成熟。学習リソースが少ない。採用実績が限定的 |
| **Vue.js (Nuxt)** | チーム内のReact経験を活かせない。Reactエコシステムの恩恵を受けられない |
| **Angular** | 学習曲線が急。重量級フレームワーク。このプロジェクト規模には過剰 |

### TypeScript

**採用理由:**

1. **型安全性**
   - 金融計算における型エラーの防止
   - リファクタリングの安全性向上

2. **開発体験**
   - IDE補完による生産性向上
   - 早期のエラー検出

3. **保守性**
   - コードの意図が明確
   - ドキュメントとしての役割

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **JavaScript (素のJS)** | 型エラーが実行時まで検出されない。大規模開発に不向き。金融計算でのミスが許容できない |

### Tailwind CSS

**採用理由:**

1. **開発速度**
   - ユーティリティクラスによる高速開発
   - カスタムCSSの記述量削減

2. **一貫性**
   - デザインシステムの統一が容易
   - スペーシング、カラーの標準化

3. **パフォーマンス**
   - 未使用CSSの自動削除
   - 最小限のバンドルサイズ

4. **保守性**
   - グローバルCSSの衝突回避
   - コンポーネントとスタイルの局所性

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **CSS Modules** | ボイラープレートが多い。デザインシステムの統一が困難。開発速度が遅い |
| **Styled Components** | ランタイムコスト。バンドルサイズが大きい。SSRとの相性問題 |
| **Bootstrap** | カスタマイズが困難。独自デザインには不向き。バンドルサイズが大きい |
| **Material-UI** | 重量級。独自デザインの実現が困難。バンドルサイズの増加 |

### Chart.js

**採用理由:**

1. **シンプルさ**
   - 学習曲線が緩やか
   - 基本的なグラフは簡単に実装可能

2. **十分な機能**
   - 財務データの可視化に必要な機能を網羅
   - プラグインによる拡張性

3. **パフォーマンス**
   - Canvas APIベースで高速
   - 大量データの描画にも対応

4. **軽量**
   - バンドルサイズが小さい
   - Tree-shaking対応

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Recharts** | React依存。パフォーマンスがChart.jsに劣る。複雑なグラフの描画が遅い |
| **D3.js** | 学習曲線が急。過剰な機能。このプロジェクトには複雑すぎる |
| **Victory** | バンドルサイズが大きい。パフォーマンス問題。カスタマイズが複雑 |
| **ECharts** | 中国製で日本語ドキュメントが不足。バンドルサイズが大きい |

### React Hook Form + Zod

**採用理由:**

1. **パフォーマンス**
   - 非制御コンポーネントでリレンダリング最小化
   - フォーム全体の再レンダリングを回避

2. **型安全なバリデーション**
   - TypeScriptとの完全な統合
   - スキーマから型を自動生成

3. **開発体験**
   - シンプルなAPI
   - 少ないボイラープレート

4. **エラーハンドリング**
   - きめ細かいエラー管理
   - カスタムバリデーションが容易

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Formik** | パフォーマンス問題。リレンダリングが多い。大規模フォームでは重い |
| **React Final Form** | エコシステムが小さい。メンテナンス頻度が低い |
| **手動実装** | バリデーションロジックが複雑化。保守コストが高い。再利用性が低い |

---

## バックエンド

### Go言語

**採用理由:**

1. **パフォーマンス**
   - コンパイル言語による高速実行
   - 並行処理（Goroutine）の効率性
   - メモリ効率が良い

2. **シンプルさ**
   - 学習曲線が緩やか
   - 言語仕様が小さく理解しやすい
   - 標準ライブラリが充実

3. **型安全性**
   - 静的型付けによる安全性
   - コンパイル時のエラー検出

4. **デプロイの容易さ**
   - 単一バイナリで配布可能
   - 依存関係の管理が簡単
   - クロスコンパイル対応

5. **並行処理**
   - 複数ユーザーの計算処理を効率的に処理
   - Goroutineによる軽量なスレッド

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Node.js (Express/NestJS)** | シングルスレッドで計算処理に不向き。型安全性がGoに劣る（TypeScriptでも）。メモリ使用量が多い |
| **Python (Django/FastAPI)** | 実行速度が遅い。GILによる並行処理の制約。デプロイが複雑（依存関係管理） |
| **Java (Spring Boot)** | 起動時間が長い。メモリ消費が大きい。設定が複雑。小規模チームには重厚すぎる |
| **Rust** | 学習曲線が急峻。開発速度が遅い。このプロジェクトには過剰な安全性。エコシステムが未成熟 |
| **C# (.NET)** | Windowsとの親和性が高いが、Linuxデプロイが複雑。ランタイムの依存関係。バンドルサイズが大きい |

### Echo Framework

**採用理由:**

1. **パフォーマンス**
   - Go製Webフレームワークの中で最速クラス
   - 軽量で高速なルーティング

2. **シンプルさ**
   - ミドルウェアの実装が容易
   - 学習コストが低い

3. **機能の充実**
   - ミドルウェアが豊富
   - バリデーション組み込み
   - グループルーティング対応

4. **メンテナンス**
   - アクティブに開発されている
   - 大規模なコミュニティ

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Gin** | パフォーマンスは同等だが、Echoの方がミドルウェアが充実。APIドキュメントがEchoの方が良い |
| **Fiber** | Express風のAPIだがGoの思想に合わない。fasthttp依存で標準net/httpと互換性がない |
| **Chi** | 軽量すぎて機能不足。ミドルウェアを自前で実装する必要がある |
| **標準ライブラリ (net/http)** | ルーティングが貧弱。ミドルウェアの実装コストが高い。開発速度が遅い |

---

## データベース

### PostgreSQL 15

**採用理由:**

1. **信頼性**
   - ACID特性の完全な実装
   - データの整合性保証
   - 金融データに必須の信頼性

2. **機能の豊富さ**
   - トリガー、ストアドプロシージャ
   - 複雑なクエリのサポート
   - JSON型による柔軟性

3. **拡張性**
   - UUID、全文検索などの拡張機能
   - カスタム型の定義が可能

4. **パフォーマンス**
   - インデックス最適化
   - パーティショニング対応
   - 将来的な大規模化にも対応可能

5. **コミュニティとエコシステム**
   - 豊富なドキュメント
   - 大規模な導入実績
   - ツールとライブラリの充実

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **MySQL** | トランザクションの実装がPostgreSQLに劣る。JSON型のサポートが弱い。拡張機能が少ない |
| **MongoDB** | NoSQLは金融データの整合性管理に不向き。トランザクションサポートが限定的。スキーマレスはバグの温床 |
| **SQLite** | 並行書き込みに弱い。大規模化に対応不可。本番環境には不適切 |
| **Microsoft SQL Server** | ライセンスコスト。Linuxサポートが限定的。Dockerイメージが重い |
| **Oracle** | 高額なライセンスコスト。小規模プロジェクトには過剰。学習コストが高い |

### データベース設計: UUID vs Auto Increment

**UUIDを採用した理由:**

1. **分散システム対応**
   - 将来的な水平分割に対応
   - マスター-スレーブ構成での衝突回避

2. **セキュリティ**
   - IDから総数が推測できない
   - シーケンシャルIDによる列挙攻撃を防止

3. **マイグレーション**
   - 他システムとのデータ統合が容易
   - ID衝突を気にせずマージ可能

**Auto Incrementを検討したが排除:**
- セキュリティリスク（ID推測）
- 分散システムでの衝突リスク
- 将来的な拡張性の制約

---

## 認証・認可

### JWT (JSON Web Token)

**採用理由:**

1. **ステートレス**
   - サーバー側でセッション管理不要
   - 水平スケーリングが容易

2. **標準規格**
   - 業界標準の認証方式
   - 多様なライブラリとツール

3. **クロスドメイン対応**
   - フロントエンドとバックエンドの分離に適合
   - SPAとの相性が良い

4. **拡張性**
   - クレームによる柔軟な権限管理
   - リフレッシュトークンとの組み合わせ

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **セッションベース認証** | 水平スケーリングが困難。セッションストアが必要。SPAとの相性が悪い |
| **OAuth 2.0のみ** | 自社認証も必要。ソーシャルログインだけでは不十分 |
| **Basic認証** | 安全性が低い。毎回認証情報の送信が必要。UXが悪い |

### bcrypt

**採用理由:**

1. **セキュリティ**
   - ソルト自動生成
   - 計算コストの調整可能
   - レインボーテーブル攻撃への耐性

2. **実績**
   - 長年の使用実績
   - セキュリティ監査済み

3. **Go標準ライブラリ**
   - golang.org/x/crypto/bcrypt
   - メンテナンスが保証されている

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **SHA-256** | ソルトを自前で管理必要。ハッシュ速度が速すぎてブルートフォース攻撃に弱い |
| **Argon2** | Goのライブラリが不安定。bcryptで十分なセキュリティレベル |
| **PBKDF2** | bcryptの方が実装が簡単で安全性も同等 |

### WebAuthn / FIDO2 (パスキー)

**採用理由:**

1. **最新のセキュリティ標準**
   - フィッシング耐性
   - 公開鍵暗号による安全性

2. **ユーザビリティ**
   - パスワードレス認証
   - 生体認証対応

3. **将来性**
   - 業界標準として普及中
   - Apple、Google、Microsoftがサポート

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **SMSベース2FA** | SIMスワップ攻撃のリスク。コストが高い。国際対応が困難 |
| **メールベース2FA** | メールアカウントが侵害されると突破される。セキュリティレベルが低い |

---

## インフラストラクチャ

### Docker + Docker Compose

**採用理由:**

1. **環境の一貫性**
   - 開発、ステージング、本番で同一環境
   - "Works on my machine"問題の解決

2. **開発体験**
   - 新規メンバーのセットアップが容易
   - 依存関係の管理が簡単

3. **デプロイの簡素化**
   - イミュータブルなデプロイ
   - ロールバックが容易

4. **リソース効率**
   - VMより軽量
   - 複数サービスの並行実行が効率的

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Kubernetes** | 小規模プロジェクトには過剰。運用コストが高い。学習コストが高い |
| **仮想マシン** | 起動が遅い。リソース消費が大きい。イメージサイズが大きい |
| **ローカルインストール** | 環境差異問題。セットアップが複雑。依存関係の衝突 |

### Render.com

**採用理由:**

1. **シンプルさ**
   - 設定が簡単
   - GitHubとの統合が容易
   - プレビュー環境の自動作成

2. **コスト**
   - 小規模プロジェクトに適した価格
   - 無料プランから開始可能

3. **機能**
   - PostgreSQL Managed Database
   - 自動SSL証明書
   - 自動スケーリング

4. **開発者体験**
   - デプロイが高速
   - ログとメトリクスの可視化
   - 環境変数管理が容易

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **AWS (ECS/EKS)** | 設定が複雑。運用コストが高い。小規模チームには過剰。学習コストが高い |
| **Vercel** | バックエンドのホスティングが限定的。Serverless Functionsの制約。PostgreSQLが別途必要 |
| **Heroku** | 価格改定で高額化。Render.comの方がコスパが良い |
| **DigitalOcean App Platform** | Render.comより機能が少ない。プレビュー環境機能が弱い |
| **Google Cloud Run** | GCPの知識が必要。Render.comより設定が複雑。課金体系が複雑 |
| **オンプレミス** | 初期投資が大きい。運用負荷が高い。スケーラビリティに制約 |

### GitHub Actions

**採用理由:**

1. **統合性**
   - GitHubと完全統合
   - 追加の設定不要

2. **無料枠**
   - パブリックリポジトリは無料
   - プライベートでも十分な無料枠

3. **機能**
   - マトリックスビルド
   - 豊富なアクション
   - シークレット管理

4. **エコシステム**
   - Marketplaceの充実
   - コミュニティアクション

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **Jenkins** | セルフホストの運用コスト。設定が複雑。モダンなUXに欠ける |
| **CircleCI** | 無料枠が限定的。GitHubとの統合がGitHub Actionsに劣る |
| **GitLab CI** | GitLabへの移行が必要。学習コストが高い |
| **Travis CI** | 無料プランの廃止。価格が高い |

---

## 開発ツール

### Air (Goホットリロード)

**採用理由:**

1. **開発速度**
   - コード変更後の自動再起動
   - 手動再起動の手間を削減

2. **シンプルさ**
   - 設定ファイルが簡単
   - Dockerとの統合が容易

3. **安定性**
   - Goコミュニティで広く使用
   - アクティブにメンテナンス

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **CompileDaemon** | 機能がAirに劣る。設定の柔軟性が低い |
| **Realize** | 設定が複雑。Airの方がシンプル |
| **手動再起動** | 開発体験が悪い。生産性が低下 |

### golangci-lint

**採用理由:**

1. **包括性**
   - 複数のリンターを統合
   - 設定が一元化

2. **パフォーマンス**
   - 並列実行による高速化
   - キャッシュ機能

3. **カスタマイズ性**
   - プロジェクトに合わせた設定が可能
   - 段階的な導入が可能

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **個別リンター実行** | 設定が分散。実行が遅い。メンテナンスコストが高い |
| **go vet のみ** | チェック項目が少ない。コード品質が保証できない |

### ESLint + Prettier

**採用理由:**

1. **コード品質**
   - 潜在的なバグの検出
   - ベストプラクティスの強制

2. **一貫性**
   - コードスタイルの統一
   - レビューの効率化

3. **エコシステム**
   - 豊富なプラグイン
   - エディタ統合

**検討した代替案:**

| 代替案 | 排除理由 |
|--------|----------|
| **TSLint** | 非推奨（ESLintに統合）|
| **StandardJS** | カスタマイズ性が低い。プロジェクトの要件に合わない |
| **手動コードレビュー** | スケールしない。人的ミスが発生。レビュー時間の増加 |

---

## まとめ

### 技術選定の原則

このプロジェクトの技術選定は、以下の原則に基づいています：

1. **実用性重視**: 実績があり、安定した技術を選択
2. **学習コストとのバランス**: 新技術より既知の技術を優先
3. **保守性**: 長期的なメンテナンスが可能な技術
4. **コミュニティ**: 活発なコミュニティとエコシステム
5. **適切なスケール**: プロジェクト規模に見合った技術選択

### 将来的な技術変更の可能性

以下の技術は、プロジェクトの成長に応じて再検討する可能性があります：

- **キャッシング**: Redis/Memcachedの導入
- **検索**: Elasticsearchの導入（大規模データ検索）
- **メッセージキュー**: RabbitMQ/Kafkaの導入（非同期処理）
- **オーケストレーション**: Kubernetesへの移行（大規模化時）
- **API**: GraphQLの追加（フロントエンド最適化）

ただし、これらは現時点では**過剰設計**であり、必要性が明確になった時点で検討します。

---

**最終更新日**: 2026-02-03  
**メンテナー**: 開発チーム
